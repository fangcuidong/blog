# vue相关

## vue2和vue3的区别有哪些？

官方迁移指南链接：https://v3-migration.vuejs.org/zh/

1. 双向绑定方法不同

   Vue2: Object.defineProperty()
   	(后添加的属性无法劫持，需要用$set)
   Vue3: new Proxy()
   	(代理整个对象，后续添加的属性也能劫持，还不需要递归对象)
   	移除$set方法，因为new Proxy()不需要手动调用方法劫持

2. 语法不同：Vue2 是选项式API，Vue3 是组合式API和向下兼容选项式API

3. v-if 和 v-for优先级不同

4. ref和$children不同

## vue常见问题

### 对MVVM的理解？

MVVM是Model-View-ViewModel的缩写，Model代表数据模型负责业务逻辑和数据封装，View代表UI组件负责界面和显示，ViewModel监听模型数据的改变和控制视图行为，处理用户交互，简单来说就是通过双向数据绑定把View层和Model层连接起来。在MVVM架构下，View和Model没有直接联系，而是通过ViewModel进行交互，我们只关注业务逻辑，不需要手动操作DOM，不需要关注View和Model的同步工作。

### vue等单页面应用及优缺点

vue核心是一个响应的数据绑定系统，mvvm，数据驱动，组件化，轻量，简洁，高效，快速，模块友好。

缺点：不支持低版本浏览器，最低到IE9，不利于SEO的优化，首页加载时间较长，不可以使用浏览器的导航按钮需要自行实现前进后退。

### **响应式原理**

劫持getter setter

Vue2: `Object.defineProperty()`
	(后添加的属性无法劫持，需要用$set)
Vue3: `new Proxy()`
	(代理整个对象，后续添加的属性也能劫持，还不需要递归对象)

### 双向绑定原理

`v-model`是一个`input`事件和`value`的语法糖



### vue常见的修饰符

- `lazy`修饰符作用是，改变输入框的值时绑定的lazyValue不会改变，当光标离开输入框时，`v-model`绑定的值lazyValue才会改变。
- `trim`修饰符的作用是把v-model绑定的值的首尾`空格`给去掉。在实际开发中我们一般用于搜索框的内容修饰，`过滤`掉用户多输入前后空格导致内容查不出来的情况。
- `number`修饰符的作用是将值转成数字，但是先输入字母的话，修饰符无效。
- `stop`修饰符的作用是阻止`事件冒泡`。
- `once`修饰符的作用是，事件只执行一次。
-  `prevent`修饰符的作用是阻止默认事件（例如a标签的跳转）
- `native`修饰符是加在自定义组件的事件上，保证事件能执行。
- `alt ctrl`
- `sync`在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。

### 计算属性和watch的区别

对数据进行固定处理时，用计算属性。

当需要在数据变化时做异步或者开销比较大的操作时，用watch 。

区别：

- 使用方式上 计算属性是依据响应式属性得出的计算属性，使用时需要调用，且不加（），会缓存数据，在响应式属性更新时，计算属性也更新。 侦听器不需要调用，会在侦听属性发生变化时，自动调用。 注意，计算属性必须 return 一个结果，也就是处理后的计算属性的值。而侦听器则不需要。
- 使用场景上 计算属性多用于依据一个或多个响应式属性得到另一个计算属性。比如：姓+名=全名。比如购物车结算金额时。 侦听器多用于复杂场景或需要异步操作时，比如搜索时实时出现搜索建议或提示。

注意：计算属性里不能有异步操作。

### 组件通信


在 Vue.js 中，组件通信是非常重要的，它可以使得不同组件之间进行数据传递、状态管理、事件触发等操作。以下是一些常见的 Vue.js 组件通信方式：

1. **Props 和事件**：
   - 父组件通过 Props 向子组件传递数据。
   - 子组件通过触发事件向父组件传递数据。
2. **事件总线（Event Bus）**：
   - 使用一个空的 Vue 实例作为中央事件总线，通过 `$emit` 和 `$on` 来触发和监听事件。
3. **Vuex 状态管理**：
   - 使用 Vuex 来管理组件之间共享的状态，通过定义状态、mutations、actions、getters 来实现组件间的数据共享和通信。
4. **Provide/Inject**：
   - 使用 `provide` 和 `inject` 来向子孙组件传递数据，不论组件嵌套层级有多深，都能轻松访问到数据。
5. **$refs**：
   - 使用 `ref` 属性给组件或 DOM 元素赋予一个唯一的引用 ID，然后通过 `$refs` 来直接访问子组件或 DOM 元素。
6. **$parent 和 $children**：
   - 使用 `$parent` 和 `$children` 来访问父组件和子组件的实例，从而直接操作其数据和方法。
7. **$emit 和 $on**：
   - 在 Vue 实例或组件中使用 `$emit` 触发自定义事件，然后在父组件中使用 `$on` 监听该事件，从而实现组件之间的通信。
8. **跨组件通信插件**：
   - 如 EventBus、Vue Bus、mitt 等第三方库，用于简化组件之间的通信，提供了更便捷的 API。

### vue组件的生命周期

Vue.js 的生命周期是指 Vue 实例从开始创建到销毁的过程，这个过程总共分为八个阶段，每个阶段对应一个特定的钩子函数。以下是 Vue.js 的生命周期钩子函数：

1. **beforeCreate（创建前）**
   - 此时尚未开始创建 Vue 实例，数据观测(data observer) 和 event/watcher 事件配置都未初始化。
   - 在这个阶段不能访问到 data、methods、computed 等属性或方法。
2. **created（创建后）**
   - 在这个阶段，Vue 实例已经完成以下的配置：数据观测(data observer)，属性和方法的运算，以及 watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。
   - 可以在这个阶段访问到 data 中的值，进行一些初始化操作，如发送网络请求等。
3. **beforeMount（挂载前）**
   - 在挂载开始之前被调用：相关的 render 函数首次被调用。
   - 此时模板已经编译到内存中，但是尚未把模板渲染到页面中。
4. **mounted（挂载后）**
   - el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。
   - 如果 root 实例挂载了一个 in-document 元素，当 mounted 被调用时 vm.$el 也在文档内。
   - 此时可以访问到 DOM 元素，通常进行一些 DOM 操作或插件初始化。
5. **beforeUpdate（更新前）**
   - 数据更新时调用，发生在虚拟 DOM 打补丁之前。
   - 可以在这个钩子中访问现有的 DOM，比如手动移除已添加的事件监听器。
6. **updated（更新后）**
   - 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
   - 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。
7. **beforeDestroy（销毁前）**
   - 实例销毁之前调用。在这一步，实例仍然完全可用。
   - 可以在这个阶段进行一些清理工作，如移除定时器、解绑全局事件、销毁插件对象等。
8. **destroyed（销毁后）**
   - Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑，所有的事件监听器都会被移除，所有的子实例也会被销毁。

### keep-alive 生命周期

`keep-alive` 是 Vue.js 的一个内置组件，它主要用于缓存不活动的组件实例，而不是销毁它们。当组件在 `<keep-alive>` 内被切换时，它的激活和停用状态会触发特定的生命周期钩子。

对于被 `<keep-alive>` 包裹的组件，其生命周期钩子如下：

1. activated：
   - 当组件被激活时调用。这意味着组件已经渲染到 DOM 中，并且现在是可见的。
   - 这个钩子在组件第一次渲染后也会被调用，以及在每次缓存组件被重新激活时调用。
2. deactivated：
   - 当组件被停用时调用。这通常发生在组件被切换为另一个组件时。
   - 组件虽然被停用，但它的状态会被保留，因此下一次激活时不需要重新渲染。

### diff算法

Diff算法，全称为Difference算法，是一种用于比较和查找文本、源代码或任何字符串之间差异的算法。它能够识别在两个文本之间进行的插入、删除和修改操作，然后生成描述这些操作的补丁文件或差异文件。这种算法在多个领域都有广泛的应用。

在前端开发中，Diff算法尤其重要，特别是在处理虚拟DOM的更新时。以Vue框架为例，其内部的Diff算法是一种用来比较新旧虚拟DOM节点的高效算法。它的主要目标是最小化DOM操作的数量，提高性能和效率。当组件状态发生变化时，Vue会使用Diff算法找出虚拟DOM树中变化的部分，并只更新这些部分，而不是重新渲染整个DOM树。这大大提升了渲染效率，特别是在处理大型或复杂的DOM结构时。

Vue的Diff算法具有一些显著的特点。首先，它只在同层级进行比较，不会跨层级比较。其次，在比较过程中，它会从两边向中间进行循环比较。此外，它会优先找到相同且不需要移动的节点，然后找到相同但需要移动的节点，最后才会创建或删除节点。Vue通过tag和key来判断两个节点是否相同，其中tag代表节点的类型，而key则是用来标识和区分不同节点的属性。

总的来说，Diff算法在前端开发中扮演着关键的角色，它使得我们能够高效、准确地更新DOM，从而提升应用的性能和用户体验。

## 性能优化相关

### 首屏加载速度优化


在单页面应用（SPA）中，首屏速度的优化对于提升用户体验至关重要。以下是一些常见的SPA应用首屏速度优化方式：

1. **代码分割（Code Splitting）**：
   - 将应用拆分成多个小模块或路由，按需加载，减少首次加载时需要下载的资源大小，提升首屏加载速度。可以使用工具如Webpack的动态导入功能进行代码分割。
2. **懒加载（Lazy Loading）**：
   - 将页面中的部分组件或模块延迟加载，只在需要时才加载相关资源，减少首次加载时需要下载的资源量。在Vue.js中，可以使用Vue Router的懒加载功能。
3. **优化图片加载**：
   - 使用适当的图片格式（如WebP）、压缩图片大小、使用图片懒加载等方式来优化图片加载，减少首屏渲染时间。
4. **预加载关键资源**：
   - 对于首屏必须要加载的关键资源（如CSS、JavaScript、字体等），可以使用预加载（preload）和预解析（prefetch）等技术来提前加载这些资源，加快页面渲染速度。
5. **服务端渲染（SSR）**：
   - 使用服务端渲染技术，将部分页面内容在服务端生成并返回给客户端，可以加速首屏渲染速度，提升用户体验。例如，使用Vue.js可以使用Vue SSR来进行服务端渲染。
6. **缓存策略**：
   - 合理利用浏览器缓存和CDN缓存，减少重复加载资源的次数，从而提升页面加载速度。可以使用HTTP缓存头、使用CDN等方式来优化缓存策略。
7. **压缩代码和资源**：
   - 对JavaScript、CSS、HTML等静态资源进行压缩和混淆，减少文件大小，加快下载速度。可以使用Webpack、Gulp等构建工具进行代码压缩。
8. **使用SSG（Static Site Generator）**：
   - 对于内容不经常变化的页面，可以使用静态网站生成器生成静态HTML文件，减少服务器响应时间，提高页面加载速度。



### 项目优化

**Vue 项目性能优化 — 实践指南**  https://juejin.cn/post/6844903913410314247

代码层面：

- **减少不必要的DOM操作**：频繁操作DOM会导致页面重绘和重排，影响性能，应该尽量避免。
- **优化JavaScript性能**：避免使用过多的全局变量和闭包，减少内存占用；使用事件委托减少事件绑定次数；避免使用过多的嵌套循环和递归，优化算法和数据结构。
- **代码拆分和懒加载**：拆分大型应用为多个小模块，按需加载，减少首屏加载时间。

构建层面：

- **压缩和合并资源**：压缩JavaScript、CSS和HTML文件，减小文件体积；合并多个小文件为一个大文件，减少HTTP请求次数，提高加载速度。
- **使用缓存**：利用浏览器缓存机制，设置合适的缓存头，减少资源的重复加载；使用CDN加速静态资源的加载。
- **异步加载**：将不需要立即加载的资源，如图片、JavaScript文件等，延迟加载或异步加载，提高页面加载速度。

网络层面：

- **开启 gzip 压缩**

- **浏览器缓存**

- **CDN 的使用**

- 定位性能瓶颈、问题：

  使用 Chrome Performance 查找性能瓶颈：
  
  Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。
  
  1. 打开 Chrome 开发者工具，切换到 Performance 面板
  2. 点击 Record 开始录制
  3. 刷新页面或展开某个节点
  4. 点击 Stop 停止录制



**ChatGPT：**

优化前端项目性能是一个持续的过程，涉及多个方面。以下是一些常见的优化性能的方式：

1. **压缩和合并资源**：
   - 压缩JavaScript、CSS和HTML文件，减小文件体积。
   - 合并多个小文件为一个大文件，减少HTTP请求次数，提高加载速度。

2. **使用缓存**：
   - 利用浏览器缓存机制，设置合适的缓存头，减少资源的重复加载。
   - 使用CDN（内容分发网络）加速静态资源的加载，提高访问速度。

3. **异步加载**：
   - 将不需要立即加载的资源，如图片、JavaScript文件等，延迟加载或异步加载，提高页面加载速度。
   - 使用Webpack等构建工具的动态导入功能进行代码分割，按需加载页面所需的资源。

4. **优化图片**：
   - 使用适当的图片格式（如WebP）和压缩技术，减小图片大小。
   - 使用CSS sprites或iconfont来减少图片请求次数。

5. **减少重绘和重排**：
   - 避免频繁操作DOM，尽量减少页面的重绘和重排，提高页面渲染性能。
   - 使用CSS硬件加速来优化动画效果，减少CPU消耗。

6. **代码优化**：
   - 避免使用过多的全局变量和闭包，减少内存占用。
   - 使用事件委托来优化事件处理，减少事件绑定的次数。
   - 避免使用过多的嵌套循环和递归，优化算法和数据结构。

7. **服务端渲染（SSR）**：
   - 使用服务端渲染技术，提前生成HTML页面并返回给客户端，减少首屏加载时间。

8. **性能监控和优化**：
   - 使用性能分析工具（如Chrome DevTools、Lighthouse等）对项目进行性能评估和监控，发现和解决性能瓶颈。

9. **前端框架和库的选择**：
   - 选择轻量级和高性能的前端框架和库，避免不必要的依赖和复杂性。

10. **代码拆分和懒加载**：
    - 拆分大型应用为多个小模块，按需加载，减少首屏加载时间。



### nginx 优化

## SPA理解

SPA（Single Page Application，单页面应用）是一种Web应用程序架构，其核心思想是在浏览器中加载单个HTML页面，并使用异步加载页面所需的资源（如HTML、CSS、JavaScript、数据等），在用户与应用程序交互时通过JavaScript动态更新页面内容，而无需重新加载整个页面。以下是对SPA模式的一些理解：

1. **单页面**：SPA只有一个HTML页面，通常是一个入口文件，所有的页面切换和内容更新都在这个页面中完成，通过JavaScript动态渲染。
2. **前端路由**：SPA使用前端路由来管理页面的导航和状态。通过监听URL的变化，根据不同的URL路径渲染不同的页面内容，而不是通过传统的页面刷新来实现。
3. **异步加载**：SPA在初始化时只加载必要的资源（如页面结构、公共样式、脚本等），而其他页面内容和数据则通过异步加载的方式获取。这种方式可以提高页面加载速度和用户体验。
4. **动态更新**：SPA通过JavaScript动态更新页面内容，通过AJAX请求获取数据，并使用前端框架（如Vue.js、React、Angular等）来管理和渲染页面状态，使页面内容可以实时响应用户的操作。
5. **优点**：
   - 用户体验好：页面切换流畅，无需频繁刷新页面，减少了页面加载时间。
   - 前后端分离：前端负责页面的展示和交互逻辑，后端负责数据的处理和接口提供，有利于团队协作和项目维护。
   - 客户端缓存：SPA可以利用浏览器的缓存机制，提高页面加载速度和性能。
6. **缺点**：
   - 首屏加载慢：由于需要加载大量的JavaScript和数据，首屏加载时间可能会较长。
   - SEO优化困难：由于大部分内容是通过JavaScript动态生成的，搜索引擎爬虫难以获取到页面的真实内容，对SEO不友好。
   - 内存占用较高：由于页面内容是动态生成的，可能会占用较多的内存，特别是在移动设备上。

综上所述，SPA模式通过前端路由、异步加载和动态更新等技术手段，实现了页面的动态渲染和用户交互，提高了用户体验，但也面临着首屏加载慢、SEO优化困难等挑战。

## Vue.js 和 Angular 的区别

Vue.js 官方文档介绍：https://v2.cn.vuejs.org/v2/guide/comparison.html



**ChatGPT 3.5：**

Vue.js 和 Angular 都是流行的前端框架，但它们在设计理念、使用方式和特点上有一些明显的区别：

1. **学习曲线**：
   - Vue.js 的学习曲线相对较低，因为它的核心库相对轻量，文档清晰易懂，更容易上手。
   - Angular 的学习曲线相对陡峭，因为它是一个完整的 MVC 框架，包含了更多的概念和复杂的特性，需要更多的时间和精力来学习和掌握。
2. **语法和模板**：
   - Vue.js 使用基于 HTML 的模板语法，将模板和逻辑更紧密地结合在一起，使得代码更加清晰易读。
   - Angular 使用 TypeScript 编写代码，并采用了自己独特的模板语法，通过指令和属性来描述组件的行为和结构。
3. **组件化**：
   - Vue.js 和 Angular 都支持组件化开发，但在实现上有所不同。
   - Vue.js 的组件化更加灵活，可以通过选项对象或单文件组件来定义组件，使得组件的编写和复用更加简单。
   - Angular 的组件化更加严格，组件必须通过 Angular CLI 工具生成，需要按照一定的约定来组织代码，使得组件的开发和维护更加规范化。
4. **状态管理**：
   - Vue.js 提供了Vuex作为官方的状态管理工具，可以帮助管理应用的状态，实现组件之间的通信和数据共享。
   - Angular 提倡使用服务（Services）来管理状态，也支持使用 RxJS 来实现响应式编程。
5. **生态系统和社区支持**：
   - Vue.js 的生态系统相对较小，但也拥有庞大的社区支持和丰富的第三方插件。
   - Angular 的生态系统更加庞大，包含了更多的官方工具和库，但相应的学习成本和依赖也更高。

综上所述，Vue.js 更加轻量灵活，适合中小型项目和个人开发者；而 Angular 更适合大型复杂的企业级应用，提供了更完整的解决方案和更严格的约束。选择哪个框架取决于项目需求、团队技术栈和个人偏好。

**通义灵码：**

Vue.js 和 Angular 是两种流行的前端 JavaScript 框架，它们各自有着不同的设计理念、架构和使用场景。以下是两者之间主要的区别：

1. **学习曲线和复杂度**
   - **Vue**: Vue 以其简洁的设计和易于理解的 API 而著称，拥有相对平缓的学习曲线。它的核心库关注视图层，对于新手开发者来说更容易上手，适合小型到大型项目。
   - **Angular**: Angular 提供了一个全栈型的框架，包含了很多特性如依赖注入、路由、表单处理等，这使得 Angular 的学习曲线相比 Vue 更陡峭。它更适合大型企业级应用开发，但对于初学者可能需要更多时间去熟悉。
2. **框架规模与灵活性**
   - **Vue**: Vue 是一个渐进式框架，这意味着你可以逐步引入所需的功能，从简单的视图层库开始，逐渐增加状态管理、路由等功能。Vue 更注重灵活性和自由度，可以根据项目需求选择是否使用配套的工具和库。
   - **Angular**: Angular 是一个全方位的框架，自带了诸如RxJS、Angular Router、Forms等全套解决方案。它要求开发者遵循严格的架构模式，但这也意味着一旦掌握后，项目开发有一致性且高度结构化。
3. **渲染与模板**
   - **Vue**: 使用基于模板的渲染语法，允许在HTML文件中直接编写Vue指令 (`v-xxx`) 进行数据绑定，同时支持JavaScript表达式和计算属性。
   - **Angular**: 也使用基于组件的模板系统，但其指令语法是 `ng-xxx`。Angular 支持更为复杂的模板逻辑，比如管道（pipes）和模板引用变量等。
4. **数据绑定与响应式系统**
   - **Vue**: 基于ES5的getter/setter实现高效的双向数据绑定，利用Object.defineProperty或proxy实现响应式数据系统，Vue 3.x 中采用了proxy来改进性能和减少“脏”检查。
   - **Angular**: 早期版本（AngularJS, Angular 1.x）使用脏检查机制实现双向绑定，而在Angular 2+版本中，引入了基于Zone.js和变更检测策略的响应式系统。
5. **性能与体积**
   - **Vue**: 体积较小，加载速度快，优化得当的情况下在性能表现上相当出色，尤其在移动端应用有明显优势。
   - **Angular**: 由于包含了更多的功能，Angular 库的体积相对较大，但在现代网络环境下可以通过懒加载和tree-shaking等手段优化性能。
6. **生态与社区**
   - **Vue**: Vue 生态系统虽不及Angular庞大，但也在迅速成长，拥有一系列官方和第三方插件、库以及丰富的文档资源。
   - **Angular**: 由Google维护，拥有成熟的生态系统，大量的企业级应用案例，社区活跃且有强大的支持。

总结来说，Vue.js 通常被看作是一种轻量级、灵活的选择，特别适合快速迭代和小型到中型项目，而 Angular 则提供了一整套企业级应用解决方案，适用于大规模、高复杂度的应用场景。开发者可以根据具体需求权衡选择。

# JS

## 原型链

原型链是JavaScript中一种用于实现对象继承的机制。在JavaScript中，每个对象都有一个指向其原型（prototype）的引用，而原型本身也是一个对象，拥有自己的原型，这样就形成了一个由原型对象构成的链式结构，即原型链。当我们访问一个对象的属性或方法时，如果该对象自身没有定义该属性或方法，JavaScript会沿着原型链向上查找，直到找到对应的属性或方法，或者最终到达原型链的顶端（Object.prototype）。这个过程称为属性或方法的查找或继承。通过原型链，可以实现对象之间的属性和方法的共享和继承。

例如，当创建一个新对象时，可以将其原型设置为某个已存在的对象，这样新对象就可以继承该对象的属性和方法。同时，构造函数和原型之间存在紧密的关系，通过构造函数可以创建实例对象，而实例对象则继承了构造函数原型对象中的所有属性和方法。

总结来说，原型链是JavaScript中对象继承的核心机制，它使得对象可以共享和继承属性和方法，从而实现代码的复用和扩展。

## 事件循环

js是单线程的脚本语言，在同一时间，只能做同一件事，为了协调事件、用户交互、脚本、UI渲染和网络处理等行为，防止主线程阻塞，Event Loop方案应运而生...

当遇到一个异步事件后，并不会一直等待异步事件返回结果，而是会将这个事件挂在与执行栈不同的队列中，我们称之为任务队列(Task Queue)。

**当主线程将执行栈中所有的代码执行完之后，主线程将会去查看任务队列是否有任务**。如果有，那么主线程会依次执行那些任务队列中的回调函数。

异步任务分为 宏任务（macrotask） 与 微任务 (microtask)，不同的API注册的任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。

**宏任务(macrotask)：**：

script(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境)

**微任务(microtask)：**

Promise、 MutaionObserver、process.nextTick(Node.js环境）

<!-- ![img](./list.assets/164081cfd8400f92tplv-t2oaga2asx-jj-mark3024000q75.webp) -->

## 闭包

解释：闭包是指有权访问另一个函数作用域中变量的函数

作用：

- 保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。
- 保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化

使用场景：防抖节流、柯里化函数

带来的问题：造成内存漏泄。解决办法：将对象指向`null`。

## 防抖节流

**防抖（debounce）和节流（throttle）**是前端开发中常用的两种优化高频率触发事件的技术手段。

**防抖（debounce）**：
防抖是指在事件被触发n秒后再执行回调，如果在这n秒内又被重新触发，则重新计算执行时间。这种技术常用于限制某个函数在一定时间内的执行次数，比如搜索框实时搜索、窗口大小调整时的重绘等场景。

实现防抖的基本思路是：在事件触发时，设定一个定时器，如果定时器还在等待中，则清除该定时器并重新设置。当定时器到时间后，再执行回调函数。

**节流（throttle）**：
节流是指如果持续触发事件，每n秒只会执行一次回调。这种技术常用于限制某个函数的执行频率，比如滚动加载、鼠标移动等场景。

实现节流的基本思路是：在事件触发时，检查是否已经有定时器在执行回调，如果没有则设定一个定时器，在定时器到时间后执行回调，并清除该定时器。如果已经有定时器在执行回调，则不进行操作。

**使用场景**：

- 防抖：适用于那些需要用户停止输入一段时间（比如500ms）后才执行的操作，如搜索框实时搜索、窗口大小调整时的重绘等。
- 节流：适用于那些需要限制执行频率的场景，如滚动加载、鼠标移动、高频点击事件等。

**实现**：
防抖和节流的实现都可以使用JavaScript的定时器（setTimeout或setInterval）来完成。在实现时，需要注意清除之前的定时器以避免不必要的执行，并且需要处理函数执行上下文（this）和参数传递的问题。在实际开发中，也可以使用一些库或框架提供的防抖和节流函数，如lodash的debounce和throttle函数。 low da si

```javascript
function debounce(func, wait) {  
    let timeout;  
    return function() {  
        const context = this;  
        const args = arguments;  
        clearTimeout(timeout);  
        timeout = setTimeout(function() {  
            func.apply(context, args);  
        }, wait);  
    };  
}

function throttle(func, limit) {  
    let inThrottle;  
    return function() {  
        const context = this;  
        const args = arguments;  
        if (!inThrottle) {  
            func.apply(context, args);  
            inThrottle = true;  
            setTimeout(function() {  
                inThrottle = false;  
            }, limit);  
        }  
    };  
}  
```

## 继承

在 JavaScript 中，ES5 和 ES6 提供了不同的方式来实现继承。以下是对这两种方式的简要说明：

### ES5 的继承实现

在 ES5 中，通常使用原型链或者借助构造函数来实现继承。最常见的模式是组合使用这两种方法，被称为“组合继承”（也称为伪经典继承）。

#### 1. 原型链继承

通过将一个类型的实例赋值给另一个类型的原型，实现继承。

```javascript
function Parent() {  
    this.name = 'parent';  
    this.play = [1, 2, 3];  
}  
  
function Child() {  
    this.type = 'child';  
}  
  
// 继承 Parent  
Child.prototype = new Parent();  
  
var child1 = new Child();  
var child2 = new Child();  
  
child1.play.push(4);  
console.log(child1.play); // 输出: [1, 2, 3, 4]  
console.log(child2.play); // 输出: [1, 2, 3, 4]
```

这种方式的缺点是，在创建 `Child` 的实例时，`Parent` 构造函数会被调用一次。如果 `Parent` 构造函数中有一些不必要的操作（比如，接受参数），那么这样做就会有问题。同时，`Child` 的所有实例会共享 `Parent` 实例的属性（如上面的 `play` 数组），这通常不是我们想要的。

#### 2. 组合继承

结合了原型链继承和构造函数继承。

```javascript
function Parent(name) {  
    this.name = name;  
    this.play = [1, 2, 3];  
}  
  
function Child(name, age) {  
    Parent.call(this, name); // 继承属性  
    this.age = age;  
}  
  
// 继承方法  
Child.prototype = Object.create(Parent.prototype);  
Child.prototype.constructor = Child;  
  
var child1 = new Child('Tom', 10);  
var child2 = new Child('Jerry', 11);  
  
child1.play.push(4);  
console.log(child1.play); // 输出: [1, 2, 3, 4]  
console.log(child2.play); // 输出: [1, 2, 3]
```

这里 `Child.prototype = Object.create(Parent.prototype);` 创建了一个新对象，其原型是 `Parent` 的原型对象，然后将这个新对象赋值给 `Child.prototype`。这样，`Child` 可以继承 `Parent` 的原型方法和属性。

### ES6 的继承实现

在 ES6 中，引入了 `class` 关键字，使得继承的语法更加简洁明了。实际上，`class` 只是语法糖，JavaScript 仍然是基于原型的。

#### 1. 使用 `extends` 和 `super` 关键字

```javascript
class Parent {  
    constructor(name) {  
        this.name = name;  
        this.play = [1, 2, 3];  
    }  
  
    sayHello() {  
        console.log(`Hello, ${this.name}`);  
    }  
}  
  
class Child extends Parent {  
    constructor(name, age) {  
        super(name); // 调用父类的 constructor  
        this.age = age;  
    }  
  
    sayAge() {  
        console.log(`I'm ${this.age} years old.`);  
    }  
}  
  
const child = new Child('Alice', 12);  
child.sayHello(); // 输出: Hello, Alice  
child.sayAge(); // 输出: I'm 12 years old.
```

在 ES6 的 `class` 中，`extends` 关键字用于表示一个类继承自另一个类。`super` 关键字用于调用父类的方法。注意，在 `Child` 的构造函数中，必须首先调用 `super` 方法，否则 `this` 将不会被初始化。

总的来说，ES6 的类语法提供了更加清晰和易于理解的继承机制，使得 JavaScript 的面向对象编程更加完善。

# HTML+CSS

## -语义化

## -BFC

## -居中

### 水平居中

### 垂直居中



# 浏览器

## -DOM与BOM区别

## 浏览器存储

在浏览器中，常见的存储方式包括 Cookie、Web Storage（包括 localStorage 和 sessionStorage）、IndexedDB 和 Cache API。以下是它们的简单介绍和区别：

1. **Cookie**：
   - **简介**：Cookie 是一种存储在客户端的小型文本数据，由服务器发送到浏览器，并在之后的请求中被浏览器发送到服务器，用于跟踪用户会话、用户偏好设置等。
   - **特点**：每个 Cookie 的大小通常限制在4KB左右，可以设置过期时间，支持跨域访问，但是每次请求都会携带 Cookie，可能会影响性能。

2. **Web Storage**：
   - **localStorage**：
     - **简介**：localStorage 用于长期保存整个网站的数据，存储在浏览器中，没有过期时间。
     - **特点**：每个域名下的 localStorage 存储空间大小通常限制在 5MB 左右，数据保存在浏览器关闭后仍然存在，不会自动清除。
   - **sessionStorage**：
     - **简介**：sessionStorage 用于临时保存网站的数据，仅在当前会话期间有效，当浏览器窗口关闭后会被清除。
     - **特点**：与 localStorage 类似，但数据仅在当前会话期间有效，关闭浏览器窗口后会被清除。

3. **IndexedDB**：
   - **简介**：IndexedDB 是一种支持大量数据存储和高性能检索的客户端数据库，使用键值对存储数据，并提供异步 API 访问数据。
   - **特点**：IndexedDB 支持存储大量结构化数据，提供了复杂的查询和索引功能，适用于需要大量客户端数据存储和高级查询的应用。

4. **Cache API**：
   - **简介**：Cache API 是浏览器提供的一种缓存机制，用于存储 HTTP 请求的响应数据，包括网页、图片、脚本等资源，以提高网页的加载性能。
   - **特点**：Cache API 可以手动控制缓存的内容和生命周期，支持离线访问和资源更新策略，适用于需要离线访问和定制缓存策略的应用。

总的来说，Cookie 是最古老的浏览器存储方式，但功能相对简单，容量小且不安全；Web Storage 提供了更大的存储空间和更好的性能，适用于简单的键值对数据存储；IndexedDB 提供了强大的客户端数据库功能，适用于复杂的结构化数据存储和查询；Cache API 则专注于缓存 HTTP 请求的响应数据，适用于提高网页加载性能。选择合适的存储方式取决于具体的需求和场景。

## cookie存放jwt有什么优势

JWT（JSON Web Tokens）存储在Cookie中时，结合了Cookie和JWT各自的优势，并在特定场景下提供了以下优势：

1. **无状态验证**：
   - JWT包含经过服务器签名的所有必要的用户信息或授权信息，存储在客户端的Cookie中。服务器无需在内存或数据库中存储会话状态，即可通过验证签名来确认请求的有效性。
2. **易于跨域访问**：
   - 如果将JWT作为HTTP-only Cookie的一部分发送，它可以跨越子域名，简化了API调用或者单点登录（SSO）场景下的跨域认证过程。
3. **安全性增强**：
   - JWT可以设置为`HttpOnly`属性，防止其被JavaScript脚本读取，从而降低XSS攻击盗取Token的风险。
   - 可以使用`Secure`属性强制JWT只能通过HTTPS传输，确保数据在传输过程中的加密安全。
4. **可扩展性和灵活性**：
   - JWT中包含的载荷(payload)部分可以携带自定义的声明（claims），这些声明可以在不同服务之间共享和验证，增强了系统的可伸缩性和互操作性。
5. **生命周期控制**：
   - 由于JWT包含了过期时间(expiration time)，服务器可以根据这个时间自动处理令牌的有效性，而不需要依赖于传统的session清理机制。
6. **减少服务器负载**：
   - 因为JWT的验证过程是无状态的，所以当应用程序部署到多个服务器时，无需维护复杂的会话同步机制，有助于提升系统的性能和可扩展性。

然而，尽管有这些优势，但将JWT存放在Cookie中也需要注意一些安全实践，例如避免存放敏感信息以及对JWT进行合理的有效期管理等。



# 工程化

## 对工程化的理解

**通义灵码：**

前端项目工程化是对前端开发流程的一种规范化和自动化处理方式，其核心目标是提升开发效率、保证代码质量、简化协作流程以及优化项目部署与维护。下面从几个方面详细阐述前端项目工程化：

1. **模块化**：通过CommonJS、ES6 Modules等模块化方案将不同的功能或组件分割为独立的模块，方便复用和管理。
2. **构建工具**：如Webpack、Rollup等，它们可以对源代码进行编译、打包、压缩、优化等一系列处理，支持模块导入导出、CSS预处理器、静态资源管理等功能，将开发环境下的模块化代码转换为浏览器可识别的格式。
3. **自动化任务管理**：如Gulp、Grunt、npm scripts或者更现代的工具如gulp、Lerna等，用于自动化执行日常开发中重复的任务，如编译、压缩、测试、部署等。
4. **包管理与依赖管理**：NPM或Yarn作为主流的包管理工具，可以方便地安装、管理和更新项目依赖，确保版本的一致性和项目的可复现性。
5. **脚手架工具**：如Create React App、Vue CLI等，能够快速初始化项目结构，内置了最佳实践的配置，简化开发环境的搭建过程。
6. **开发流程标准化**：包括代码规范检查（ESLint）、格式化（Prettier）、测试（Jest、Mocha等）、持续集成/持续部署（CI/CD）等，以保证代码质量和团队协作效率。
7. **组件化与设计系统**：在大型项目中，通常会采用组件化的方式组织UI元素，并通过Storybook、Styleguidist等工具来管理组件库和设计系统，提高复用度和一致性。

总之，前端项目工程化是一套完整的解决方案，涵盖了从项目创建到上线运维的各个环节，旨在提升整体开发效率和产品质量，更好地适应现代Web应用开发的复杂需求。

---

**ChatGPT 3.5：**

前端工程化是指利用工程化的方法和工具来提高前端开发效率、规范开发流程、优化项目质量和维护性的一种开发方式。它涵盖了一系列的工具、流程和最佳实践，以确保前端项目能够更高效地开发、构建、测试和部署。

以下是我对前端工程化的理解：

1. **自动化构建**：通过构建工具（如Webpack、Parcel等），自动化地将源代码转换、合并、压缩、打包，以提高页面加载性能、减少资源请求次数。
2. **模块化开发**：采用模块化的开发方式（如CommonJS、ES6 Modules等），将代码按功能拆分成多个模块，提高代码的可维护性和复用性。
3. **代码规范和静态检查**：使用工具（如ESLint、Prettier等）对代码进行规范检查和格式化，以确保团队成员遵循统一的编码规范，提高代码质量。
4. **版本控制和代码管理**：利用版本控制系统（如Git），管理代码的版本历史，方便团队协作、代码回滚和版本发布。
5. **持续集成和持续部署**：通过持续集成（CI）和持续部署（CD）的方式，自动化地将代码集成、测试和部署到生产环境，加速交付周期，降低发布风险。
6. **性能优化和调试工具**：利用性能分析工具（如Lighthouse、WebPageTest等）对页面性能进行监测和优化，提高页面加载速度和用户体验。
7. **文档和注释**：编写清晰的代码注释和项目文档，方便团队成员理解和维护代码。
8. **测试**：采用单元测试、集成测试、端到端测试等各种测试手段，保证代码的质量和稳定性。

综上所述，前端工程化是一种综合性的开发方式，通过引入工程化的流程和工具，可以提高团队的开发效率、降低项目风险、提高代码质量，从而更好地满足用户需求并保持竞争力。



# 网络相关

## 什么是跨域

跨域，也称为跨域资源共享（CORS，Cross-Origin Resource Sharing），主要指的是浏览器在执行一个脚本时，由于安全限制，无法请求与自身来源不同的域（即协议、域名或端口任一不同）的资源。这是由浏览器的同源策略造成的，是浏览器为了保障用户数据安全而施加的安全限制。

**解决方法**:

解决跨域问题有多种方法，下面列举几种常见的方式：

1. JSONP：
   - 利用`<script>`标签没有跨域限制的漏洞，通过动态创建`<script>`标签，并且设置其`src`属性为跨域URL，以此来实现跨域数据的获取。
   - JSONP只支持GET请求。
2. CORS（跨域资源共享）：
   - 在服务器端设置响应头`Access-Control-Allow-Origin`，允许指定的域进行访问。
   - 可以设置其他CORS相关的响应头，如`Access-Control-Allow-Methods`来指定允许的请求方法。
3. 代理服务器：
   - 在服务器端设置一个代理服务器，前端请求该代理服务器，然后由代理服务器去请求真正的目标服务器，最后返回数据给前端。
   - 可以使用Node.js、Nginx等搭建代理服务器。
4. postMessage + iframe：
   - 通过在页面中嵌入一个与目标域同源的`iframe`，然后使用`window.postMessage`方法发送消息给`iframe`，再由`iframe`与目标服务器通信，最后将数据发回给主页面。
5. WebSocket：
   - WebSocket协议不受同源策略限制，可以实现跨域通信。
   - 前端与服务器建立WebSocket连接后，可以通过该连接进行数据的双向传输。
6. 设置代理：
   - 在开发环境中，可以使用webpack-dev-server等工具的代理功能，将跨域请求转发到目标服务器。
7. 使用第三方库：
   - 有些第三方库或框架提供了跨域请求的封装，如axios库可以通过配置实现CORS请求。

在选择跨域解决方案时，需要根据具体的应用场景、安全需求以及技术栈来综合考虑。同时，也需要注意跨域请求可能带来的安全风险，如数据泄露、CSRF攻击等，因此在实际应用中需要采取相应的安全措施。

## 从输入URL到页面加载的全过程

[链接](https://juejin.cn/post/7206541359950397500)

**①** 首先会进行DNS解析，从浏览器缓存到本地HOST文件查询到运营商DNS查询，找到服务器IP地址；

**②** 然后是TCP连接，进行三次握手：



<!-- ![2286877-20220424192945060-744932028.png](./list.assets/1466a500f1364600b02e5f0e1e573c74tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp) -->

**第一次握手**
客户端会主动发送连接请求报文，随机初始化序列号为 x，并把 SYN 标志位设置为 1，表示 SYN 报文。
客户端发送 SYN 报文后，客户端进入 syn_sent 状态。

---

**第二次握手**
服务端收到 SYN 报文后，服务端会发送 SYN-ACK 报文，用于对客户端发送的 SYN 报文进行应答。
服务端会随机初始化序列号为 y，确认序列号设置为 x + 1，并把 SYN 标志位、ACK 标志位设置为 1。
服务端发送 SYN-ACK 报文后，服务端进入 syn_receive 状态。

---

**第三次握手**
客户端收到 SYN-ACK 报文后，客户端会发送 ACK 报文，用于对服务端发送的报文进行应答。
客户端会将序列号设置为 x + 1，确认序列号设置为 y + 1，ACK 标志位设置为 1。
客户端发送 ACK 报文后，客户端处于 established 状态。
当服务端收到 ACK 报文后，服务端进入 established 状态。

---

此时 TCP 连接就建立完成了，客户端和服务端就可以相互发送数据了。

**③ ** SSL/TLS 握手

建立 SSL 协议：

1. 客户端向服务端获取公钥
2. 双方协商生成对称密钥
3. 使用对称密钥进行加密通信

四次握手：

<!-- ![img](./list.assets/b3216c864b214155858f11adc49ff7aatplv-k3u1fbpfcp-jj-mark3024000q75.webp) -->

1. 客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
2. 服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
3. 客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端，同时根据三个随机数生成对称密钥。客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务器校验。
4. 服务端使用自己的私钥，获取客户端发来的随机数（即Premaster secret），同时根据三个随机数生成对称密钥。服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

为什么需要三个随机数？

1. 使用随机数生成密钥可以保证每次生成的密钥不同，增加密钥安全性。
2. SSL 协议不信任每个主机能生成完全随机的随机数，所以通过客户端和服务端生成的三次（伪）随机数生成接近完全随机数的随机数。

④⑤⑥⑦



1. vue响应式原理，双向绑定原理？

   

    

   

1. 说一下http缓存？强制缓存和协商缓存？
2. 怎么实现图片懒加载的？
3. 如何解决跨域？
4. 事件循环
5. es6新特性
6. BFC是什么？
7. flex属性有哪些？
8. 数组的方法有哪些？forEach和map的区别？foreach为什么不能使用break，continue和return打断？那怎么打断forEach的循环？



- css垂直居中
- vite为什么快？对比其他打包工具有什么优势缺点
- 

- nginx http压缩 http协议 tcp间联时间